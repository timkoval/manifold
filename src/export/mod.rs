//! Markdown rendering and export for specs
//!
//! Converts JSON-canonical specs to human-readable Markdown documentation

use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

use crate::models::{SpecData, Requirement, Task, Decision, Priority, TaskStatus};

/// Export format options
#[derive(Debug, Clone, Copy)]
pub enum ExportFormat {
    /// Single spec to Markdown
    Markdown,
    /// Multiple specs to single document
    MultiMarkdown,
    /// Spec with table formatting
    MarkdownTables,
}

/// Markdown renderer for specs
pub struct MarkdownRenderer;

impl MarkdownRenderer {
    /// Render a spec to Markdown string
    pub fn render_spec(spec: &SpecData, with_tables: bool) -> String {
        let mut md = String::new();

        // Title and metadata
        md.push_str(&format!("# {}\n\n", spec.name));
        md.push_str(&format!("> **Project:** {}  \n", spec.project));
        md.push_str(&format!("> **Spec ID:** {}  \n", spec.spec_id));
        md.push_str(&format!("> **Boundary:** {}  \n", spec.boundary));
        md.push_str(&format!("> **Stage:** {}  \n", spec.stage));
        md.push_str(&format!("> **Stages Completed:** {:?}  \n", spec.stages_completed));
        md.push_str("\n---\n\n");

        // Table of Contents
        md.push_str("## Table of Contents\n\n");
        md.push_str("1. [Workflow Status](#workflow-status)\n");
        md.push_str("2. [Requirements](#requirements)\n");
        md.push_str("3. [Design Decisions](#design-decisions)\n");
        md.push_str("4. [Tasks](#tasks)\n");
        md.push_str("5. [Change History](#change-history)\n");
        md.push_str("\n---\n\n");

        // Workflow Status
        md.push_str("## Workflow Status\n\n");
        md.push_str(&Self::render_workflow_status(spec));
        md.push_str("\n");

        // Requirements
        md.push_str("## Requirements\n\n");
        if spec.requirements.is_empty() {
            md.push_str("*No requirements defined yet.*\n\n");
        } else {
            if with_tables {
                md.push_str(&Self::render_requirements_table(&spec.requirements));
            } else {
                md.push_str(&Self::render_requirements_list(&spec.requirements));
            }
        }

        // Design Decisions
        md.push_str("## Design Decisions\n\n");
        if spec.decisions.is_empty() {
            md.push_str("*No design decisions documented yet.*\n\n");
        } else {
            md.push_str(&Self::render_decisions(&spec.decisions));
        }

        // Tasks
        md.push_str("## Tasks\n\n");
        if spec.tasks.is_empty() {
            md.push_str("*No tasks defined yet.*\n\n");
        } else {
            if with_tables {
                md.push_str(&Self::render_tasks_table(&spec.tasks));
            } else {
                md.push_str(&Self::render_tasks_list(&spec.tasks));
            }
        }

        // Change History
        md.push_str("## Change History\n\n");
        md.push_str(&Self::render_history(spec));

        // Footer
        md.push_str("\n---\n\n");
        md.push_str(&format!("*Generated by Manifold on {}*\n",
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));

        md
    }

    /// Render workflow status with visual progress
    fn render_workflow_status(spec: &SpecData) -> String {
        let stages = ["requirements", "design", "tasks", "approval", "implemented"];
        let current_stage = spec.stage.to_string();
        
        let mut status = String::new();
        status.push_str("```\n");
        
        for (i, stage) in stages.iter().enumerate() {
            let is_current = *stage == current_stage;
            let is_completed = spec.stages_completed.iter()
                .any(|s| s.to_string() == *stage);
            
            if is_current {
                status.push_str(&format!("  [{:^15}]", stage.to_uppercase()));
            } else if is_completed {
                status.push_str(&format!("  âœ“ {:^13}", stage));
            } else {
                status.push_str(&format!("  Â· {:^13}", stage));
            }
            
            if i < stages.len() - 1 {
                status.push_str(" â†’");
            }
        }
        
        status.push_str("\n```\n\n");
        
        // Summary stats
        status.push_str(&format!("- **Requirements:** {}\n", spec.requirements.len()));
        status.push_str(&format!("- **Tasks:** {}\n", spec.tasks.len()));
        status.push_str(&format!("- **Decisions:** {}\n", spec.decisions.len()));
        
        status
    }

    /// Render requirements as a list
    fn render_requirements_list(requirements: &[Requirement]) -> String {
        let mut md = String::new();
        
        for req in requirements {
            md.push_str(&format!("### {} - {}\n\n", req.id, req.title));
            
            // Metadata
            md.push_str(&format!("**Capability:** {}  \n", req.capability));
            md.push_str(&format!("**Priority:** {} ({})\n\n", 
                Self::priority_emoji(&req.priority), req.priority));
            
            // SHALL statement
            md.push_str("#### Requirement\n\n");
            md.push_str(&format!("> {}\n\n", req.shall));
            
            // Rationale
            if let Some(rationale) = &req.rationale {
                md.push_str("#### Rationale\n\n");
                md.push_str(&format!("{}\n\n", rationale));
            }
            
            // Tags
            if !req.tags.is_empty() {
                md.push_str(&format!("**Tags:** {}\n\n", req.tags.join(", ")));
            }
            
            // Scenarios
            if !req.scenarios.is_empty() {
                md.push_str("#### Scenarios\n\n");
                for scenario in &req.scenarios {
                    md.push_str(&format!("**{}** ({})\n\n", scenario.name, scenario.id));
                    
                    md.push_str("- **GIVEN**\n");
                    for given in &scenario.given {
                        md.push_str(&format!("  - {}\n", given));
                    }
                    md.push_str(&format!("- **WHEN** {}\n", scenario.when));
                    md.push_str("- **THEN**\n");
                    for then in &scenario.then {
                        md.push_str(&format!("  - {}\n", then));
                    }
                    
                    if !scenario.edge_cases.is_empty() {
                        md.push_str("- **EDGE CASES**\n");
                        for edge in &scenario.edge_cases {
                            md.push_str(&format!("  - {}\n", edge));
                        }
                    }
                    md.push_str("\n");
                }
            }
            
            md.push_str("---\n\n");
        }
        
        md
    }

    /// Render requirements as a table
    fn render_requirements_table(requirements: &[Requirement]) -> String {
        let mut md = String::new();
        
        md.push_str("| ID | Title | Priority | SHALL Statement |\n");
        md.push_str("|---|---|---|---|\n");
        
        for req in requirements {
            let priority = format!("{} {}", Self::priority_emoji(&req.priority), req.priority);
            let shall = req.shall.replace('\n', " ");
            md.push_str(&format!("| {} | {} | {} | {} |\n",
                req.id, req.title, priority, shall));
        }
        
        md.push_str("\n");
        
        // Detailed sections follow
        for req in requirements {
            md.push_str(&format!("### {} - {}\n\n", req.id, req.title));
            
            if let Some(rationale) = &req.rationale {
                md.push_str(&format!("**Rationale:** {}\n\n", rationale));
            }
            
            if !req.scenarios.is_empty() {
                md.push_str(&format!("**Scenarios:** {}\n\n", req.scenarios.len()));
                for scenario in &req.scenarios {
                    md.push_str(&format!("- {} ({})\n", scenario.name, scenario.id));
                }
                md.push_str("\n");
            }
        }
        
        md
    }

    /// Render design decisions
    fn render_decisions(decisions: &[Decision]) -> String {
        let mut md = String::new();
        
        for decision in decisions {
            md.push_str(&format!("### {} - {}\n\n", decision.id, decision.title));
            md.push_str(&format!("**Date:** {}\n\n", decision.date));
            
            md.push_str("#### Context\n\n");
            md.push_str(&format!("{}\n\n", decision.context));
            
            md.push_str("#### Decision\n\n");
            md.push_str(&format!("> {}\n\n", decision.decision));
            
            md.push_str("#### Rationale\n\n");
            md.push_str(&format!("{}\n\n", decision.rationale));
            
            if !decision.alternatives_rejected.is_empty() {
                md.push_str("#### Alternatives Considered\n\n");
                for alt in &decision.alternatives_rejected {
                    md.push_str(&format!("- {}\n", alt));
                }
                md.push_str("\n");
            }
            
            md.push_str("---\n\n");
        }
        
        md
    }

    /// Render tasks as a list
    fn render_tasks_list(tasks: &[Task]) -> String {
        let mut md = String::new();
        
        for task in tasks {
            md.push_str(&format!("### {} - {}\n\n", task.id, task.title));
            md.push_str(&format!("**Status:** {} {}\n\n",
                Self::task_status_emoji(&task.status), task.status));
            
            md.push_str(&format!("{}\n\n", task.description));
            
            if !task.requirement_ids.is_empty() {
                md.push_str(&format!("**Traces to:** {}\n\n",
                    task.requirement_ids.join(", ")));
            }
            
            if let Some(assignee) = &task.assignee {
                md.push_str(&format!("**Assignee:** {}\n\n", assignee));
            }
            
            if !task.acceptance.is_empty() {
                md.push_str("**Acceptance Criteria:**\n\n");
                for criteria in &task.acceptance {
                    md.push_str(&format!("- {}\n", criteria));
                }
                md.push_str("\n");
            }
            
            md.push_str("---\n\n");
        }
        
        md
    }

    /// Render tasks as a table
    fn render_tasks_table(tasks: &[Task]) -> String {
        let mut md = String::new();
        
        md.push_str("| ID | Title | Status | Requirements | Assignee |\n");
        md.push_str("|---|---|---|---|---|\n");
        
        for task in tasks {
            let status = format!("{} {}", Self::task_status_emoji(&task.status), task.status);
            let reqs = task.requirement_ids.join(", ");
            let assignee = task.assignee.as_deref().unwrap_or("-");
            
            md.push_str(&format!("| {} | {} | {} | {} | {} |\n",
                task.id, task.title, status, reqs, assignee));
        }
        
        md.push_str("\n");
        md
    }

    /// Render change history
    fn render_history(spec: &SpecData) -> String {
        let mut md = String::new();
        
        md.push_str(&format!("- **Created:** {}\n",
            chrono::DateTime::from_timestamp(spec.history.created_at, 0)
                .map(|dt| dt.format("%Y-%m-%d %H:%M UTC").to_string())
                .unwrap_or_else(|| "unknown".to_string())));
        
        md.push_str(&format!("- **Last Updated:** {}\n\n",
            chrono::DateTime::from_timestamp(spec.history.updated_at, 0)
                .map(|dt| dt.format("%Y-%m-%d %H:%M UTC").to_string())
                .unwrap_or_else(|| "unknown".to_string())));
        
        if !spec.history.patches.is_empty() {
            md.push_str("### Recent Changes\n\n");
            
            for patch in spec.history.patches.iter().rev().take(10) {
                let timestamp = chrono::DateTime::from_timestamp(patch.timestamp, 0)
                    .map(|dt| dt.format("%Y-%m-%d %H:%M").to_string())
                    .unwrap_or_else(|| "unknown".to_string());
                
                md.push_str(&format!("- **{}** | {} | {} | {}\n",
                    timestamp, patch.actor, patch.op, patch.summary));
            }
        }
        
        md
    }

    /// Get emoji for priority
    fn priority_emoji(priority: &Priority) -> &'static str {
        match priority {
            Priority::Must => "ğŸ”´",
            Priority::Should => "ğŸŸ¡",
            Priority::Could => "ğŸŸ¢",
            Priority::Wont => "âš«",
        }
    }

    /// Get emoji for task status
    fn task_status_emoji(status: &TaskStatus) -> &'static str {
        match status {
            TaskStatus::Pending => "â³",
            TaskStatus::InProgress => "ğŸ”„",
            TaskStatus::Completed => "âœ…",
            TaskStatus::Blocked => "ğŸš«",
        }
    }

    /// Export spec to Markdown file
    pub fn export_to_file(spec: &SpecData, output_path: &Path, with_tables: bool) -> Result<()> {
        let markdown = Self::render_spec(spec, with_tables);
        
        // Ensure parent directory exists
        if let Some(parent) = output_path.parent() {
            fs::create_dir_all(parent)
                .context("Failed to create output directory")?;
        }
        
        fs::write(output_path, markdown)
            .context("Failed to write Markdown file")?;
        
        Ok(())
    }

    /// Export multiple specs to a single Markdown document
    pub fn export_multi(specs: &[SpecData], output_path: &Path, with_tables: bool) -> Result<()> {
        let mut md = String::new();
        
        // Document header
        md.push_str("# Manifold Specification Collection\n\n");
        md.push_str(&format!("> Generated on {}\n\n",
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
        md.push_str("---\n\n");
        
        // Table of contents
        md.push_str("## Specifications\n\n");
        for (i, spec) in specs.iter().enumerate() {
            md.push_str(&format!("{}. [{}](#{}) - {} ({})\n",
                i + 1, spec.name, Self::anchor(&spec.name), spec.project, spec.stage));
        }
        md.push_str("\n---\n\n");
        
        // Individual specs
        for spec in specs {
            md.push_str(&Self::render_spec(spec, with_tables));
            md.push_str("\n\\pagebreak\n\n");
        }
        
        fs::write(output_path, md)
            .context("Failed to write multi-spec Markdown file")?;
        
        Ok(())
    }

    /// Create anchor link from text
    fn anchor(text: &str) -> String {
        text.to_lowercase()
            .chars()
            .map(|c| if c.is_alphanumeric() { c } else { '-' })
            .collect()
    }
}
